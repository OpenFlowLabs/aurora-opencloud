use std::path::{PathBuf, Path};
use miette::{IntoDiagnostic, Report, WrapErr};
use thiserror::Error;
use super::{Document, Action};

type Result<T> = std::result::Result<T, BundleError>;

pub const BUILD_BUNDLE_IMAGE_PATH: &str = "/build_bundle";
pub const BUILD_BUNDLE_BUILD_CONFIG_FILENAME: &str = "build.kdl";

#[derive(Debug, Error)]
pub enum BundleError {
    #[error("fs error: {0}")]
    FsError(#[from] fs_extra::error::Error),
    #[error("received an io error while reading bundle: {0}")]
    IoError(#[from] std::io::Error),
}

#[derive(Debug)]
enum BuildBundleType {
    BaseImage,
    Image,
    VM,
}

/// This Audit Info struct gets generated by calling the get_audit_info function of the build bundle
/// It contains all information needed for Applications to make Security Relevant decisions
/// For exmaple if the bundle is safe to be used as a base bundle build which runs the first IPS
/// step in a global zone.
#[derive(Debug)]
pub struct BuildBundleAuditInfo {
    bundle_type: BuildBundleType,
}

impl BuildBundleAuditInfo {
    pub fn is_safe_to_run_in_gz(&self) -> bool {
        self.is_base_image()
    }

    pub fn is_base_image(&self) -> bool {
        matches!(self.bundle_type, BuildBundleType::BaseImage)
    }
}

#[derive(Debug)]
pub enum BuildBundleKind {
    Directory,
}

#[derive(Debug)]
pub struct Bundle {
    pub kind: BuildBundleKind,
    pub document: Document,
    template_search_path: PathBuf,
    source_path: PathBuf,
}

impl Bundle {
    pub fn new(path: &Path) -> std::result::Result<Self, Report> {
        let docs_path = path.join(BUILD_BUNDLE_BUILD_CONFIG_FILENAME);
        let text = std::fs::read_to_string(&docs_path)
            .into_diagnostic()
            .wrap_err_with(|| format!("cannot read {:?}", docs_path))?;

        let document = knuffel::parse::<Document>(&docs_path.to_string_lossy(), &text)?;

        Ok(Self {
            kind: BuildBundleKind::Directory,
            document,
            template_search_path: path.join("templates").to_path_buf(),
            source_path: path.to_path_buf(),
        })
    }

    pub fn get_template_string(&self, name: &str) -> Result<String> {
        let file = self.template_search_path.join(name);
        let text = std::fs::read_to_string(&file)?;
        Ok(text)
    }

    pub fn get_path(&self) -> PathBuf {
        self.source_path.clone()
    }

    pub fn get_audit_info(&self) -> BuildBundleAuditInfo {
        let t = if self.document.base_on.is_some()
            && matches!(self.document.actions[0], Action::Ips(..))
        {
            BuildBundleType::BaseImage
        } else {
            BuildBundleType::Image
        };

        BuildBundleAuditInfo { bundle_type: t }
    }

    pub fn save_to<P: AsRef<Path>>(&self, target: P) -> Result<()> {
        let options = fs_extra::dir::CopyOptions{ 
            overwrite: true, 
            skip_exist: false, 
            buffer_size: 64000, 
            copy_inside: true, 
            content_only: true, 
            depth: 0,
        };
        fs_extra::copy_items(&[&self.source_path], target, &options)?;

        Ok(())
    }

    pub fn save_to_zone(&self, zonepath: &str) -> Result<()> {
        let path = Path::new(zonepath).join(BUILD_BUNDLE_IMAGE_PATH);
        self.save_to(path)
    }
}
