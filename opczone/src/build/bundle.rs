use super::{Action, Document};
use miette::{IntoDiagnostic, Report, WrapErr};
use std::path::{Path, PathBuf};
use thiserror::Error;

type Result<T> = std::result::Result<T, BundleError>;

pub const BUILD_BUNDLE_IMAGE_PATH: &str = "/.zonemeta/build_bundle";
pub const BUILD_BUNDLE_BUILD_CONFIG_FILENAME: &str = "build.kdl";

#[derive(Debug, Error)]
pub enum BundleError {
    #[error("fs error: {0}")]
    FsError(#[from] fs_extra::error::Error),
    #[error("received an io error while reading bundle: {0}")]
    IoError(#[from] std::io::Error),
    #[error("file {0} does not exist in bundle")]
    FileDoesExistsErr(String),
}

#[derive(Debug, PartialEq, Eq, Clone)]
enum BuildBundleType {
    BaseImage,
    Image,
    #[allow(dead_code)]
    VM,
}

/// This Audit Info struct gets generated by calling the get_audit_info function of the build bundle
/// It contains all information needed for Applications to make Security Relevant decisions
/// For exmaple if the bundle is safe to be used as a base bundle build which runs the first IPS
/// step in a global zone.
#[derive(Debug)]
pub struct BuildBundleAuditInfo {
    bundle_type: BuildBundleType,
}

impl BuildBundleAuditInfo {
    pub fn is_safe_to_run_in_gz(&self) -> bool {
        self.is_base_image()
    }

    pub fn is_base_image(&self) -> bool {
        if self.bundle_type == BuildBundleType::BaseImage {
            return true;
        }
        false
    }
}

#[derive(Debug)]
pub enum BuildBundleKind {
    Directory,
}

#[derive(Debug)]
pub struct Bundle {
    pub kind: BuildBundleKind,
    pub document: Document,
    template_search_path: PathBuf,
    source_path: PathBuf,
}

impl Bundle {
    pub fn new(path: &Path) -> std::result::Result<Self, Report> {
        let docs_path = path.join(BUILD_BUNDLE_BUILD_CONFIG_FILENAME);
        let text = std::fs::read_to_string(&docs_path)
            .into_diagnostic()
            .wrap_err_with(|| format!("cannot read {:?}", docs_path))?;

        let document = knuffel::parse::<Document>(&docs_path.to_string_lossy(), &text)?;

        Ok(Self {
            kind: BuildBundleKind::Directory,
            document,
            template_search_path: path.join("templates").to_path_buf(),
            source_path: path.to_path_buf(),
        })
    }

    pub fn get_files_path(&self) -> PathBuf {
        self.source_path.join("files")
    }

    pub fn get_template_string(&self, name: &str) -> Result<String> {
        let file = self.template_search_path.join(name);
        let text = std::fs::read_to_string(&file)?;
        Ok(text)
    }

    pub fn get_path(&self) -> &Path {
        &self.source_path
    }

    pub fn get_file<P: AsRef<Path>>(&self, relative_file_path: P) -> Result<PathBuf> {
        let full_path = self.get_files_path().join(relative_file_path.as_ref());
        if !full_path.exists() {
            return Err(BundleError::FileDoesExistsErr(
                relative_file_path.as_ref().to_string_lossy().to_string(),
            ));
        }

        Ok(full_path)
    }

    pub fn get_audit_info(&self) -> BuildBundleAuditInfo {
        let t = if self.document.base_on.is_none()
            && matches!(self.document.actions[0], Action::Ips(..))
        {
            BuildBundleType::BaseImage
        } else {
            BuildBundleType::Image
        };

        BuildBundleAuditInfo { bundle_type: t }
    }

    pub fn save_to<P: AsRef<Path>>(&self, target: P) -> Result<()> {
        let options = fs_extra::dir::CopyOptions {
            overwrite: true,
            copy_inside: true,
            ..Default::default()
        };
        fs_extra::copy_items(&[&self.source_path], target, &options)?;

        //TODO: Save progress information on disk
        //TODO: Switch source path to target

        Ok(())
    }

    pub fn save_to_zone(&self, zonepath: &str) -> Result<()> {
        let path = Path::new(zonepath).join("meta/build_bundle");
        self.save_to(path)
    }
}
